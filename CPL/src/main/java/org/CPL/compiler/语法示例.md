# 基础概念
## 语法简洁性示例
以下均以Java举例：
```java
int hitpoint = 15;
for(i = 1; i < 114; i++){
    hitpoint = hitpoint + 1;
    if(hitpoint >= i){
        hitpoint += i;
    }
    system.out.println(hitpoint);
}
```
```text
血量 = 15
循环 i 从 1 到 114
    血量 = 血量 + 1；
    当 血量 >= i 时
        血量 += i。
    打印（血量）。

```

## 装饰器语法
装饰器是CPL语言的核心，我们希望将所有的非逻辑语句全部置入装饰器，以保证在语法上不会对任何关键字存在严格意义上的需求。

这样做的原因和目的是，由于当前编译器和IDE已经得到了极大发展，在语法上静态规定开发者必须编写类型/访问符/返回值等等类型已经不再是最优解了。我们更希望在90%的平凡开发过程里通过自动完成和自动补全体系来帮助开发者对可以被确定的类型等等变量/方法属性进行自动推断。这样我们可以保证代码的编写复杂度低于语法确定化的那些传统编程语言，同时由保证定义的明确性、可读性和对复杂项目的支持强于目前的非强制声明类型的语言。

同时，装饰器声明的语法还能提供巨大的自由度，允许语言在未来的发展中兼容各种更新的编译优化技术和编译器指令，或者兼容一些更复杂的数据库ORM映射操作/Web访问标记/并发标记等等。
## 语法示例
注：以下标注`（可被自动补全）`的装饰器都是不强制要求开发者明确声明的，`（可被自动补全）`并不是代码的一部分，只是说明
### 变量定义
```text
@ 整数（可被自动补全）
年龄 = 25；

@ 字符（可被自动补全）
名字 = "张三"；

@ 布尔（可被自动补全）
是否学生 = 真；

@ 浮点 （可被自动补全）
价格 = 3.14；

@ 数组（整数）（可被自动补全）
数组示例 = [1, 2, 3, 4]；

@ 字典（字符：整数）（可被自动补全）
字典示例 = {"苹果": 3, "香蕉": 5}；

@ 常量/变量（变量是默认的，可以不显式声明），只读/可变（可变是默认的，可以不显式声明）
年龄 = 25；

@ 公开/私有/保护（如果不声明的话默认是私有的）
年龄 = 25；

@ 私有/保护，对{xx，yy，zz}公开
年龄 = 25；

@ 公开，对{xx，yy，zz}私有/保护
年龄 = 25；
```
### 运算和逻辑
注：以下标注`（可被自动补全）`的装饰器都是不强制要求开发者明确声明的，`（可被自动补全）`并不是代码的一部分，只是说明
```text
# 假设我们有变量 
# 数1 = 15；数2 = 20；数3 = 12.5；布尔1 = 真；

@ 整数（可被自动补全）
数4 = 数1 + 数2；
数4 = 数1 - 数2；
数4 = 数1 * 数2；
数4 = 数1 / 数2；
数4 = 数1 % 数2；

@ 浮点（可被自动补全和自动类型向上转换）
数4 = 数1 + 数3；
数4 = 数1 - 数3；
数4 = 数1 * 数3；
数4 = 数1 / 数3；
数4 = 数1 % 数3；

@ 整数（可被自动补全）
数4 = 数1 + （整数）数3

@ 布尔（可被自动补全）
布尔2 = 布尔1 或 真；

@ 布尔（可被自动补全）
布尔2 = 布尔1 与 真；

@ 布尔（可被自动补全）
布尔2 = 布尔1 异或 真； # 输入不同时输出真，否则为假

@ 布尔（可被自动补全）
布尔2 = 非 布尔1 或 真；

@ 布尔（可被自动补全）
布尔2 = 数1 > 数2；
布尔2 = 数1 >= 数2；
布尔2 = 数1 < 数2；
布尔2 = 数1 <= 数2；
布尔2 = 数1 == 数2；
布尔2 = 数1 ！= 数2；


@ 整数（可被自动补全）
数4 = 数1 | 数2 （按位与）
数4 = 数1 & 数2 （按位或）
数4 = ！数1 （按位非）
```
这里我们定义了：
 - 整数的四则运算（加减乘除）和取余
 - 浮点数的四则运算（加减乘除）和取余
 - 强制类型转换
 - 布尔值的基本三运算（与、或、非）和异或运算
 - 
### 分支判断
```text
若 价格 ≥ 1
    价格 = 价格 + 1；
    价格 = 价格 + 2。

若 价格 ≥ 1
    价格 = 价格 + 1；
    若 名字 == 张三
        名字 = “李四”。
    价格 = 价格 + 2。
    
若 价格 ≥ 1
    价格 = 价格 + 1；
    若 名字 == 张三 
        名字 = “李四”。
    。
（上下两种写法等价）
若 价格 ≥ 1 时
    价格 = 价格 + 1；
    若 名字 == 张三 
        名字 = “李四”。。
    
若 价格 ≥ 1
    价格 = 价格 + 1。
否则
    价格 = 价格 + 2。
    
若 价格 ≥ 1
    价格 = 价格 + 1。
否则 若 价格 ≥ 2
    价格 = 价格 + 2。  
```
这里，我们将分支语句的语法结构定义为：
```text
若 ... <换行符>
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。/。（句号代表上一个打开的分支语句的结束）
否则/否则 若 ... <换行符> （对应的是else和elif）
     <语句>；（缩进是建议但非必要的）
    ……
    <语句>。/。（句号代表上一个打开的分支语句的结束）
```
在这里，句号可以单独成一行，可以黏着在上一行尾，也可以跟随语句结束当前分支语句。这样设计的优势是更加贴近自然语言，增加可读性和可维护性。
### 循环语句
#### 计数循环
```text
循环到 9 （实际循环为0,1,2,3,4,5,6,7,8，无循环计数器）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环从 1 到 9 （实际循环为1,2,3,4,5,6,7,8，无循环计数器）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环从 1 到 9 步进 2 （实际循环为1,3,5,7，无循环计数器）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环 i 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环 i 从 1 到 9 （实际循环为1,2,3,4,5,6,7,8）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环 i 从 1 到 9 步进 2 （实际循环为1,3,5,7）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环 i 从 9 到 1 步进 -2 （实际循环为9,7,5,3）
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
@ 每步：i = (i + 3) / 2
循环 i 从 1 到 9
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
@ 初始：i = 3
@ 结束：i ≥ 12 或 i < 0
@ 每步：i = (i + 3) / 2
循环 i
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
（上下两种写法等价）
@ i = 3； i ≥ 12 或 i < 0；i = (i + 3) / 2
循环 i
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
    
循环 i 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
    <语句>；（缩进是建议但非必要的）
    循环 j 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。
    <语句>。
    
循环 i 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
    <语句>；（缩进是建议但非必要的）
    循环 j 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。
    。
（上下两种写法等价）
循环 i 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
    <语句>；（缩进是建议但非必要的）
    循环 j 到 9 （实际循环为0,1,2,3,4,5,6,7,8）
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。。
```
这里计数循环语句在设计上是有一些复杂的，目的是保证使用时的直观可读。

首先，可以使用`循环到...`、`循环从...到...`、`循环从...到...步进...`来声明一个没有显式循环计数器的循环语句，循环体内是无法访问当前循环的计数的。

其次，可以使用`循环<变量>到...`、`循环<变量>从...到...`、`循环<变量>从...到...步进...`来声明一个具备显式循环计数器（`<变量>`）的循环语句。其中，`<变量>`如果是当前范围内不存在的，会创建一个新的；如果是当前范围内已有的，则需要确保`<变量>`的类型和填入的其他变量相同，并按以下逻辑执行：
```text
循环<变量>到... --------------> 从当前<变量>的值（含）开始，到指定的值（不含）为止
循环<变量>从...到... ---------> 将当前<变量>的值设置为起始值，然后正常循环
循环<变量>从...到...步进... ---> 将当前<变量>的值设置为起始值，然后正常循环
```
再次，我们提供了兼容传统for循环的写法，开发者可以选择显式声明循环体的起始、结束和每步表达式。同时，对希望快速完成复杂循环表达式的开发者，我们也提供在装饰器里直接声明传统for循环表达式的方法。

最后，对嵌套循环语句，我们的处理方式和分支判断是一致的，也即用句号来表示闭合，句号可以独立成行，也可以黏着在上一行尾。

#### 迭代器循环
```text
遍历 <可迭代数据结构>
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。

遍历 <可迭代数据结构> 到 <变量>
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
   
遍历 <可迭代数据结构> 到 <变量>
    <语句>；（缩进是建议但非必要的）
    遍历 <可迭代数据结构> 到 <变量>
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。 
    <语句>。

遍历 <可迭代数据结构> 到 <变量>
    <语句>；（缩进是建议但非必要的）
    遍历 <可迭代数据结构> 到 <变量>
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。 
    。 （或者黏着到上一行）
```
#### 条件循环
```text
当 <条件判断语句> 时循环
    <语句>；（缩进是建议但非必要的）
    ……
    <语句>。
   
当 <条件判断语句> 时循环
    <语句>；（缩进是建议但非必要的）
    遍历 <可迭代数据结构> 到 <变量>
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。 
    <语句>。
    
当 <条件判断语句> 时循环
    <语句>；（缩进是建议但非必要的）
    遍历 <可迭代数据结构> 到 <变量>
        <语句>；（缩进是建议但非必要的）
        ……
        <语句>。 
    <语句>。
```
